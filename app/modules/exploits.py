import os
import time
import html
import flask
import shutil
import threading
import subprocess



from modules import db
from modules import log
from modules import utils
from modules import targets
from modules import settings
from modules import submitter

# Helper functions
def load_exploits():
    for exploit in os.listdir(settings.EXPLOITS_DIR):
        if exploit != "templates" and exploit != "archive":
            # Check if exploit path already exists in database
            id = str(next(db.id_iter))
            found = False
            for e in db.data["exploits"].values():
                if e["path"] == exploit:
                    try:
                        del db.data["exploits"][e["id"]]
                    except KeyError:
                        pass
                    db.data["exploits"][id] = e
                    db.data["exploits"][id]["id"] = id
                    found = True
                    break
            if found:
                continue
            name = exploit
            db.data["exploits"][id] = {
                "id": id,
                "name": name,
                "frequency": settings.EXPLOIT_DEFAULT_FREQUENCY,
                "path": name,
                "flags_captured": 0,
                "services_vulnerable": 0,
                "service_id": "",
                "log": {}
            }

def get_exploit_templates():
    return os.listdir(settings.EXPLOITS_TEMPLATES_DIR)

def get_archived_exploits():
    return os.listdir(settings.EXPLOITS_ARCHIVE_DIR)

def run_exploit_on_target(id, target):
    exploit = db.data["exploits"][id]
    exploit_path = os.path.join(settings.EXPLOITS_DIR, exploit["path"])
    os.system("chmod +x " + exploit_path)
    # Get pretty timestamp
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    # Run exploit
    try:
        output = subprocess.check_output(exploit_path + " " + target["ip"], shell=True, stderr=subprocess.STDOUT, timeout=settings.EXPLOIT_TIMEOUT)
        # Parse output for flags
        total,new = submitter.handle_data(id, target["teamid"], target["serviceid"], output.decode("utf-8"))
        # HTML encode output
        output = html.escape(output.decode("utf-8"))
        # Add to log
        msg = "Success - captured " + str(total - new) + " repeat flags, " + str(new) + " new flags"
        log.log_exploit(id, timestamp, target["team"], target["service"], target["ip"], msg, output, total, new)
        if total > 0:
            db.data["exploits"][id]["services_vulnerable"] += 1
        return total
    except Exception as e:
        log.log_exploit(id, timestamp, target["team"], target["service"], target["ip"], "Runtime failure", e, -1, -1)
        return 0

def run_exploit(id):
    # Run exploit on all targets
    exploit = db.data["exploits"][id]
    db.data["exploits"][id]["services_vulnerable"] = 0
    for target in targets.list_service_targets(exploit["service_id"]).values():
        # Run the exploit in a new thread
        t = threading.Thread(target=run_exploit_on_target, args=(id, target))
        t.start()


# Frontend views
def view_exploits():
    exploits = db.data["exploits"]
    for exploit in exploits.values():
        try:
            exploits[exploit["id"]]["service"] = db.data["services"][exploit["service_id"]]["name"]
        except KeyError:
            exploits[exploit["id"]]["service"] = ""
    return flask.render_template("exploits/index.html", exploits=exploits)

def view_archived_exploits():
    exploits = get_archived_exploits()
    services = db.data["services"]
    return flask.render_template("exploits/archived.html", exploits=exploits)

def view_new_exploit():
    template = flask.request.args.get("template")
    templates = get_exploit_templates()
    services = db.data["services"]
    if template:
        code = utils.read_file_contents(os.path.join(settings.EXPLOITS_TEMPLATES_DIR, template))
        return flask.render_template("exploits/new.html", templates = templates, code = code, services = services, messages = ["Loaded template " + template])
    else:
        return flask.render_template("exploits/new.html", templates = templates, code = "", services = services)

def view_modify_exploit():
    id = flask.request.args.get("id")
    try:
        exploit = db.data["exploits"][id]
        code = utils.read_file_contents(os.path.join(settings.EXPLOITS_DIR, exploit["path"]))
        return flask.render_template("exploits/modify.html", exploit = exploit, code = code , services = db.data["services"])
    except KeyError:
        return flask.render_template("404.html")

def view_exploit_log():
    id = flask.request.args.get("id")
    try:
        l = log.get_exploit_log(id)
    except KeyError:
        l = {}
    return flask.render_template("exploits/log.html", log = l, id = id)

def view_exploit_log_details():
    id = flask.request.args.get("exploit")
    timestamp = flask.request.args.get("timestamp")
    try:
        item = log.get_exploit_log_details(id, timestamp)
        return flask.render_template("exploits/details.html", item = item, id = id)
    except KeyError:
        return flask.render_template("404.html")


# Backened functions
def create_exploit():
    name = flask.request.form.get("name")
    code = flask.request.form.get("code")
    frequency = int(flask.request.form.get("frequency"))
    service_id = flask.request.form.get("service_id")

    name = name.strip('.').strip('/')

    id = str(next(db.id_iter))

    path = name

    # Check if the exploit already exists
    if os.path.exists(os.path.join(settings.EXPLOITS_DIR, path)):
        exists_counter = 1
        while os.path.exists(os.path.join(settings.EXPLOITS_DIR, path + "_" + str(exists_counter))):
            exists_counter += 1
        path = path + "_" + str(exists_counter)

    db.data["exploits"][id] = {
        "id": id,
        "name": name,
        "frequency": frequency,
        "path": path,
        "flags_captured": 0,
        "services_vulnerable": 0,
        "service_id": service_id,
        "log": {}
    }

    with open(os.path.join(settings.EXPLOITS_DIR, path), "w", newline='\n') as f:
        code = code.replace('\r', '')
        f.write(code)

    return flask.redirect("/exploits")

def update_exploit():
    name = flask.request.form.get("name")
    code = flask.request.form.get("code")
    frequency = int(flask.request.form.get("frequency"))
    service_id = flask.request.form.get("service_id")
    id = flask.request.form.get("id")

    old_path = db.data["exploits"][id]["path"]
    path = name

    if old_path != path:
    # Check if the exploit already exists
        if os.path.exists(os.path.join(settings.EXPLOITS_DIR, path)):
            exists_counter = 1
            while os.path.exists(os.path.join(settings.EXPLOITS_DIR, path + "_" + str(exists_counter))):
                exists_counter += 1
            path = path + "_" + str(exists_counter)

    # Delete the old file
    os.remove(os.path.join(settings.EXPLOITS_DIR, old_path))
    # Write the new file
    utils.write_file_contents(os.path.join(settings.EXPLOITS_DIR, path), code)

    db.data["exploits"][id]["name"] = name
    db.data["exploits"][id]["frequency"] = frequency
    db.data["exploits"][id]["path"] = path
    db.data["exploits"][id]["service_id"] = service_id


    return flask.redirect("/exploits")

def archive_exploit():
    id = flask.request.args.get("id")

    try:
        path = db.data["exploits"][id]["path"]
    except KeyError:
        return flask.render_template("404.html")

    shutil.move(os.path.join(settings.EXPLOITS_DIR, path), os.path.join(settings.EXPLOITS_ARCHIVE_DIR, path))
    
    del db.data["exploits"][id]

    return flask.redirect("/exploits")

def clear_exploit_log():
    id = flask.request.args.get("id")

    try:
        db.data["exploits"][id]["log"] = {}
        log.exploit_log[id] = {}
    except KeyError:
        return flask.render_template("404.html")

    return flask.redirect("/exploits/log?id=" + id)

def unarchive_exploit():
    name = flask.request.args.get("name")

    try:
        id = str(next(db.id_iter))
        path = name
        shutil.move(os.path.join(settings.EXPLOITS_ARCHIVE_DIR, name), os.path.join(settings.EXPLOITS_DIR, path))
        db.data["exploits"][id] = {
            "id": id,
            "name": path,
            "frequency": settings.EXPLOIT_DEFAULT_FREQUENCY,
            "path": path,
            "flags_captured": 0,
            "services_vulnerable": 0,
            "service_id": "",
            "log": {}
        }
    except Exception:
        return flask.render_template("404.html")

    return flask.redirect("/exploits")

def delete_exploit():
    name = flask.request.args.get("name")

    try:
        os.remove(os.path.join(settings.EXPLOITS_ARCHIVE_DIR, name))
    except Exception:
        return flask.render_template("404.html")

    return flask.redirect("/exploits/archived")

def trigger_run_exploit():
    id = flask.request.args.get("id")

    try:
        run_exploit(id)

        return flask.redirect("/exploits/log?id=" + id)
    except KeyError:
        return flask.render_template("404.html")

# Thread functions
def exploit_loop():
    timecounter = 0
    while True:
        for id in db.data["exploits"]:
            if timecounter % db.data["exploits"][id]["frequency"] == 0:
                run_exploit(id)
        time.sleep(settings.EXPLOIT_TICK_TIME)
        timecounter += settings.EXPLOIT_TICK_TIME


exploit_thread = threading.Thread(target=exploit_loop)